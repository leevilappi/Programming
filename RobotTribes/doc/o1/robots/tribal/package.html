<!DOCTYPE html >
<html>
        <head>
          <title>tribal - o1.robots.tribal</title>
          <meta name="description" content="tribal - o1.robots.tribal" />
          <meta name="keywords" content="tribal o1.robots.tribal" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../index.html';
            var hash = 'o1.robots.tribal.package';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body onload="/* Customizations for CSE-A1110: */ /* hide classtags: */ $('span.symbol span.params:contains(\'ClassTag\')').css('display', 'none');  /* fix style to accommodate long parameter names: */ $('dl.paramcmts > dd').css('margin-left', '110px'); /* pretend that toString has no parameter list: */ $('a[id=\'toString():String\']').closest('li').find('h4.signature span.symbol span.params').css('display', 'none'); /* hide most UI packages by default (needs improvement): */ $('div#tpl ol.packages li.pack a.tplshow').each(function() { if ($(this).text().match(/o1..*ui/) && $(this).text().match(/(RandomText|GoodStuff)/) == null) $(this).closest('li.pack').find('a.packhide').trigger('click') }); /* hide all inherited App stuff by default: */ $('ol#linearization').find('li').each(function() { if ($(this).text() == 'App' || $(this).text() == 'SimpleSwingApplication') $(this).closest('ol#linearization').find('li.in').trigger('click')  }); " class="value">
      <div id="definition">
        <img alt="Package" src="../../../lib/package_big.png" />
        <p id="owner"><a href="../../package.html" class="extype" name="o1">o1</a>.<a href="../package.html" class="extype" name="o1.robots">robots</a></p>
        <h1>tribal</h1><span class="permalink">
      <a href="../../../index.html#o1.robots.tribal.package" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">tribal</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        
        
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="o1.robots.tribal.Frame" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FrameextendsAnyRef"></a>
      <a id="Frame:Frame"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="Frame.html"><span class="name">Frame</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#o1.robots.tribal.package@FrameextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Each <code>Frame</code> object represents a data frame in a tribal bot's call stack.</p><div class="fullcomment"><div class="comment cmt"><p>Each <code>Frame</code> object represents a data frame in a tribal bot's call stack. A frame stores data
relevant to a single RoboSpeak subprogram call. A stack frame is associated not with the code
of a subprogram, but with a subprogram call that happens during program execution.</p><p>Tribal bots' subprogram calls -- unlike Scala methods -- don't have any parameters or local
variables, and very little data needs to be stored in each <code>CallStackFrame</code>. In fact, only a
single line number needs to be stored to indicate where the subprogram call was made (in order
to determine where program execution should resume once the bot returns from the subprogram).
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="TribalBot.html#returnFromSubprogram():Int" class="extmbr" name="o1.robots.tribal.TribalBot#returnFromSubprogram">TribalBot.returnFromSubprogram</a></p></span><span class="cmt"><p><a href="TribalBot.html#callSubprogram(callingLine:Int):scala.collection.mutable.Stack[o1.robots.tribal.Frame]" class="extmbr" name="o1.robots.tribal.TribalBot#callSubprogram">TribalBot.callSubprogram</a></p></span><span class="cmt"><p><a href="Tribe.html" class="extype" name="o1.robots.tribal.Tribe">Tribe</a></p></span></dd></dl></div>
    </li><li name="o1.robots.tribal.Instruction" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="InstructionextendsAnyRef"></a>
      <a id="Instruction:Instruction"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Instruction.html"><span class="name">Instruction</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#o1.robots.tribal.package@InstructionextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">The trait <code>Instruction</code> represents instructions within RoboSpeak programs.</p><div class="fullcomment"><div class="comment cmt"><p>The trait <code>Instruction</code> represents instructions within RoboSpeak programs.
The program of each <a href="Tribe.html" class="extype" name="o1.robots.tribal.Tribe">Tribe</a> consists of instruction objects; a <a href="TribalBot.html" class="extype" name="o1.robots.tribal.TribalBot">TribalBot</a>
is able to execute sequences of instructions.</p><p>A single <code>Instruction</code> object represents an instruction for a tribal robot to
do something. By way of example, here are two RoboSpeak instructions in textual
form, each of which can also be represented by an <code>Instruction</code> object:</p><pre>turn
goto <span class="num">1</span></pre><p>See the documentation of class <a href="Tribe.html" class="extype" name="o1.robots.tribal.Tribe">Tribe</a> for more details and examples of RoboSpeak.</p><p>There are various kinds of instruction objects representing the various kinds of
instructions that can appear in RoboSpeak programs. However, all instructions share
the common interface described by this trait. Through this interface, instructions
can be examined and executed. Each instruction object, irrespective of what is does,
provides the following:</p><ul><li>Methods for determining basic information about the instruction:
   Does executing the instruction end a tribal robot's turn? On which
   line in a RoboSpeak program does the instruction appear?</li><li>A method for executing the instruction and determining which instruction
   to execute next.</li></ul><p>An instruction object is immutable.
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="TribalBot.html" class="extype" name="o1.robots.tribal.TribalBot">TribalBot</a></p></span><span class="cmt"><p><a href="Tribe.html" class="extype" name="o1.robots.tribal.Tribe">Tribe</a></p></span></dd></dl></div>
    </li><li name="o1.robots.tribal.TribalBot" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TribalBotextendsRobotBrain"></a>
      <a id="TribalBot:TribalBot"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="TribalBot.html"><span class="name">TribalBot</span></a><span class="result"> extends <a href="../RobotBrain.html" class="extype" name="o1.robots.RobotBrain">RobotBrain</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#o1.robots.tribal.package@TribalBotextendsRobotBrain" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">The class <code>TribalBot</code> represents the &quot;brains&quot; (or AI) of robots that belong to
a &quot;robot tribe&quot; and behave according to the rules of that tribe.</p><div class="fullcomment"><div class="comment cmt"><p>The class <code>TribalBot</code> represents the &quot;brains&quot; (or AI) of robots that belong to
a &quot;robot tribe&quot; and behave according to the rules of that tribe. Tribal robots
consider other tribal robots of the same tribe their friends and all other robots
their enemies. A tribal robot is capable of attacking enemies and thereby converting
them to their own tribe. As a consequence, tribes can be quite aggressive as they
compete for survival in a robot world.</p><h4>Robot Actions</h4><p>Each tribal robot is capable of doing one (but only one) of the following
things during its turn:</p><ul><li>Moving one square forward into an empty floor space.</li><li>Spinning 90 degrees (without moving).</li><li>Attacking -- &quot;hacking&quot; -- an enemy robot immediately in front of it (see below).</li></ul><p>Hacking is automatic whenever a tribal robot sees an enemy, but how a tribal robot
moves about and spins depends on its tribe. Each tribe has its own program, written
in the RoboSpeak language. All members of the tribe follow this program, which
defines the sequences of actions that those robots take. See the documentation of
class <a href="Tribe.html" class="extype" name="o1.robots.tribal.Tribe">Tribe</a> for details about RoboSpeak.</p><h4>Hacking</h4><p>A tribal robot starts its turn by looking at whether there is an enemy robot in front
 of it. An enemy robot is any robot that is not a member of the same tribe. If there
is an enemy robot in the square right in front of the acting tribal bot, then the
tribal bot attacks it by &quot;hacking&quot;. Hacking is a kind of brainwashing: it converts
the enemy robot into a member of the acting robot's tribe. The victim will begin
executing its new tribe's RoboSpeak program from a line determined by the hacking
robot.</p><h4>Memory</h4><p>Each tribal bot has some limited memory resources available, which it draws on when
it executes the tribe's RoboSpeak program. A tribal bot remembers the following
information:</p><ul><li>Where it is: A tribal bot knows which robot body it is controlling, just like any
   other <code>RobotBrain</code> does, and can therefore determine its location and facing.</li><li>Where its allegiances lie: A tribal bot knows which tribe it belongs to</li><li>What it's supposed to do next: A tribal bot knows which instruction in its tribe's
   RoboSpeak program it is supposed to execute next once it gets its next turn.
   (This allows the tribal bot to save the program position it is in when it ends a turn.
   It can later resume program execution where it left off the previous turn.)</li><li>Which way it's turning: A tribal bot remembers if it is supposed to be turning
   clockwise or counterclockwise when it next makes a turn.</li><li>Which subprogram calls have been made: A tribal bot has a call stack where it stores
   frames representing calls to RoboSpeak subprograms. Each such frame is represented by
   a <a href="Frame.html" class="extype" name="o1.robots.tribal.Frame">Frame</a> object. This allows the tribal bot to execute subprograms and return to
   the correct location in the tribe's RoboSpeak code when the end of a subprogram is reached.</li><li>The contents of three memory slots (or &quot;registers&quot;) called <i>mem</i>, <i>radar</i> and
   <i>hackline</i>. The slot <i>mem</i> can be used by the RoboSpeak program for any purpose.
   The intended use of <i>radar</i> is to store the readings produced by the robot's radar.
   The slot <i>hackline</i> is meant for configuring hacked robots. See the text below and
   class <a href="Tribe.html" class="extype" name="o1.robots.tribal.Tribe">Tribe</a> for more details.</li></ul><h4>Sensors</h4><p>A tribal bot is (only) capable of seeing the single square directly in front of it.
It can determine what there is in that square but no further. It also has a <i>radar</i> that
can be used either <i>short-range</i> to determine how many enemies or friends are located
within exactly two steps of the acting robot, or <i>long-range</i> to count the memberships
of entire tribes in the robot world. Again, more details can be found in the documentation
for class <a href="Tribe.html" class="extype" name="o1.robots.tribal.Tribe">Tribe</a>.</p><h4>Initial state</h4><p>When a tribal bot is created, it starts executing its tribal program from the
beginning (unless otherwise specified by a hacking robot). Its call stack is initially empty,
its memory slots all contain the value 1, and it is considered to be turning clockwise.</p><p>As a new tribal bot brain &quot;plugs into&quot; a robot body, it changes the robot's name.
Each new member of a tribe receives a new rather impersonal name of the form &quot;Tribe#number&quot;,
e.g., &quot;Tiger#123&quot;. The ID number that comes after the hash (#) is unique for every member
of a tribe.</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="Frame.html" class="extype" name="o1.robots.tribal.Frame">Frame</a></p></span><span class="cmt"><p><a href="Tribe.html" class="extype" name="o1.robots.tribal.Tribe">Tribe</a></p></span></dd></dl></div>
    </li><li name="o1.robots.tribal.Tribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TribeextendsAnyRef"></a>
      <a id="Tribe:Tribe"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="Tribe.html"><span class="name">Tribe</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#o1.robots.tribal.package@TribeextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A &quot;tribe&quot; of robots is essentially a program which makes any robots who follow that program
--- the &quot;members&quot; of the tribe --- to behave in a certain way.</p><div class="fullcomment"><div class="comment cmt"><p>A &quot;tribe&quot; of robots is essentially a program which makes any robots who follow that program
--- the &quot;members&quot; of the tribe --- to behave in a certain way.</p><p><b>NOTE TO STUDENTS: In this course, you don't need to understand every aspect of this relatively
complex class. However, you should read the text below so you know how to use the RoboSpeak language.
You'll also need to modify the source code of this class a bit, as described in Chapter 12.1
of the course materials.</b></p><h4>RoboSpeak</h4><p>As a Plan A, tribal robots spend their turn attacking nearby enemies (see class <a href="TribalBot.html" class="extype" name="o1.robots.tribal.TribalBot">TribalBot</a>).
However, when there is no enemy directly in front, the tribal bot will instead follow its
tribe's program to maneuver itself.</p><p>Tribal programs are written in a programming language called <b>RoboSpeak</b>. RoboSpeak can be
described as &quot;machine code for tribal robots&quot;. It features a smallish number of simple instructions
(commands) which can be combined to build programs that direct tribal robots' actions.
A description of RoboSpeak appears below.</p><h4>Action Instructions</h4><p>There are three &quot;action instructions&quot; that cause a tribal bot to spend its turn on something concrete:</p><ul><li><i>move</i>: Attempt to move forward one step into an empty square.</li><li><i>spin</i>: Spin 90 degrees. Unless otherwise specified (see below), the robot spins clockwise.</li><li><i>wait</i>: Stand still: don't move, don't spin.</li></ul><p>Even if a robot fails to execute an action instruction (this happens if there is something
blocking movement), the attempt ends the robot's turn.</p><h4>An Introductory Example</h4><p>By themselves, action instructions are not enough to write interesting RoboSpeak programs.
To control the use of action instructions, RoboSpeak provides a variety of &quot;logic instructions&quot;
which allow a tribal bot to reason about its state and surroundings.</p><p>Here is a simple RoboSpeak program. It causes the members of a tribe to move forward as long
as they can, turning clockwise whenever they run into a wall.</p><pre>ifwall <span class="num">4</span>
move
goto <span class="num">1</span>
spin
goto <span class="num">1</span></pre><p>This program can be paraphrased as: &quot;If you see a wall in front of you, go to line 4 (where you spin clockwise
before returning to line 1). Otherwise, move one step forward and return to line 1.&quot; Either moving or spinning
ends the robot's turn. Next turn, it resumes where it left off. In this example, it so happens that the
robot will always start its turns by returning to line 1 (because both the <i>move</i> and <i>spin</i>
commands are followed by <i>goto 1</i>).</p><p>Only the two action instructions listed above end a tribal bot's turn: a robot can execute any
number of non-action instructions during a turn.</p><h4>Basic Logic</h4><p>Some basic logic instructions are:</p><ul><li><i>goto N</i>: Continue executing the program from line N.</li><li><i>switch</i>: Change the direction in which the robot spins when the <i>spin</i> instruction is executed.
               If the robot was previously spinning clockwise, it now spins counterclockwise.
               If it was spinning counterclockwise, it now spins clockwise. Note that switching
               only affects future spins; it does not actually spin the robot immediately.</li><li><i>ifempty N</i>: If there is nothing in the square in front of you, continue executing the program
               from line N, otherwise execution from the next line. The command <i>ifnempty N</i> does
               exactly the opposite, and jumps to line N if and only if the square is not empty.</li><li><i>iffriend N</i>: If there is a friend (a robot of the same tribe) in the square in front of you,
               continue executing the program from line N, otherwise continue execution from the next line.
               The command <i>ifnfriend N</i> does exactly the opposite, and jumps to line N if and only
               if there is no friend present.</li><li><i>ifwall N</i>: If there is a wall in the square in front of you, continue executing the program from
               line N, otherwise continue execution from the next line. The command <i>ifnwall N</i> does
               exactly the opposite, and jumps to line N if and only if there is no wall present.</li><li><i>ifrandom N</i>: &quot;Flip a coin&quot;: 50% chance of continuing from line N, 50% chance of continuing from
               the next line.</li></ul><h4>Labels</h4><p>Since using line number literals is highly inconvenient when editing any program longer than a
dozen lines or so, RoboSpeak allows the programmer to define <b>labels</b>. Labels are essentially
names for program locations. They can be used instead of line numbers in RoboSpeak instructions.</p><p>A label is defined by line that contains a single word (the name of the label)
followed by a colon. Here is the previous RoboSpeak program rewritten using labels:</p><pre>start:
  ifwall wallfound
  move
  goto start
wallfound:
  spin
  goto start</pre><p>A label definition itself does not instruct a tribal bot to do anything.
It is simply a name for a location in code.</p><p>Anywhere a line number is required as a parameter to a RoboSpeak instruction, a label name
may be used instead.</p><h4>Comments and Whitespace</h4><p>In RoboSpeak, the hash character (#) means that the rest of the line is a comment and does not
have any effect on robot behavior. Empty lines are likewise ignored. Using whitespace for
indentation is encouraged.</p><p>Here is a slightly more complex tribe whose code has been explained using comments.</p><pre>#########################################################
# A member of the Tiger Tribe moves straight forward,   #
# hacking anything it sees in front of it. When its     #
# route is blocked, it turns either left or right at    #
# random.                                               #
#########################################################

start:                        # Main loop: turn or move
  ifnempty turn               # turn <span class="kw">if</span> facing an obstacle
  move                        # move otherwise
  goto start                  # repeat the above

turn:                         # Turns left or right at random
  ifrandom noswitch
  switch
noswitch:
  spin
  goto start</pre><h4>Pacifist Tribes</h4><p>If a RoboSpeak program contains a line that consists of the word <i>pacifist</i>, then members of the
tribe will not try to hack anyone at the beginning of their turns (the bunny tribe is an example).</p><h4>Using Memory Slots</h4><p>Each tribal bot has three <b>memory slots</b> called <i>mem</i>, <i>radar</i> and <i>hackline</i>, each of
which can store an integer value. Some commands directly manipulate these slots:</p><ul><li><i>set S N</i>: Set the value of slot S to N. The parameter S must be a slot name. For instance,
   <i>set mem 5</i> stores the value five in <i>mem</i>, replacing any previously stored value.</li><li>A slot name can be used as a parameter value. For instance, <i>goto mem</i> causes execution to
   jump to the line indicated by the current value of <i>mem</i>, and <i>set mem radar</i> copies the
   value of <i>radar</i> into <i>mem</i>.</li></ul><p>In addition to the logic instructions listed above, RoboSpeak features a few commands that compare
numerical values. These work best in combination with memory slots:</p><ul><li><i>ifeq A B N</i>: If A equals B then continue executing the program from line N, otherwise
                   continue execution from the next line. For instance, <i>ifeq mem 100 22</i> jumps
                   to line 22 if the memory slot <i>mem</i> contains the value 100.
                   The command <i>ifneq A B N</i> does exactly the opposite, and jumps to N if and
                   only if A and B are not equal.</li><li><i>ifgt A B N</i>: If A is greater than B then continue executing the program from line N, otherwise
                   continue execution from the next line.</li><li><i>iflt A B N</i>: If A is less than B then continue executing the program from line N, otherwise
                   continue execution from the next line.</li></ul><p>The slot <i>mem</i> may be used for anything. The slots <i>radar</i> and <i>hackline</i> have
special purposes --- see below.</p><h4>Radar Commands</h4><p>The <i>radar</i> memory slot is a special one that is automatically assigned a new value whenever
the robot uses any of the available radar commands:</p><ul><li><i>enemiesnear</i>: Use the radar to find out how many non-pacifist enemy bots are
                    within two steps of the acting robot. (See diagram below.) Stores this
                    number in <i>radar</i>.</li><li><i>friendsnear</i>: Use the radar to find out how many friendly robots are within
                    two steps of the acting robot. (See diagram below.) Stores this number
                    in <i>radar</i>. The robot does not count itself as a friend.</li><li><i>foddernear</i>: Use the radar to find out how many pacifist bots are within
                   two steps of the acting robot. (See diagram below.) Stores this number
                   in <i>radar</i>. This count does not include the acting robot, even if
                   it is a pacifist one. Non-tribal bots count as pacifists for this purpose.</li><li><i>fodderleft</i>: Use the radar to produce a count of how many &quot;fodder bots&quot;
                   (see <i>foddernear</i> above) there still are in the entire robot world.
                   Stores this number in <i>radar</i>.</li><li><i>score</i>: Use the radar to produce a number that indicates who is leading the
                   ongoing tribal fight and by how much. Stores this number in <i>radar</i>.
                   A positive number means that the acting robot's tribe is more populous than
                   any other tribe in the robot world, while a negative number means that another
                   tribe is leading. The magnitude of the lead is also given: for instance, a
                   score of 5 means that the acting robot's tribe has five more members than
                   the second-placed one, and -10 means that the acting robot's tribe has ten
                   fewer members than the leading tribe. Pacifist tribes are ignored when
                   determining the score.</li></ul><p>A &quot;step&quot; means a non-diagonal move to an adjacent square. For instance, in the diagram below, robots
A, B, C, D, and E are within two steps of robot R, but robots F and G aren't. (# represents a wall,
and . represents an empty floor square.)</p><pre>###########
#..A......#
#.D#RBC...#
#.....G...#
#.F.E.....#
###########</pre><h4>Hacking and Talking</h4><p>As noted above, non-pacifist tribal bots always automatically spend their turn hacking a nearby
enemy whenever possible. When this happens, the enemy robot starts executing its tribal program from
whichever line number is stored in the hacking robot's <i>hackline</i> memory slot. As the default value of
all memory slots is 1, hacked robots start running their programs from the beginning, unless a <i>set</i>
command has been used to modify the value of <i>hackline</i>.</p><p>Robots can also affect how their existing tribemates behave. The command <i>talk N</i> transmits a
command to a nearby friendly robot. Assuming that there is a friendly robot in front of the acting
robot, the friend jumps to line N in its RoboSpeak program. The next time the friend gets a turn,
it will resume executing its program from line N onwards. If there is no friendly robot right in front
of the acting robot, this instruction achieves nothing. Talking does not end a robot's turn.</p><p>A robot that is hacked or talked to is rebooted. Its state (spinning direction, memory slots, etc.)
are reset.</p><h4>Subprograms</h4><p>RoboSpeak provides a mechanism for making subprogram calls. Subprogram calls are similar to function
calls in Scala in that they cause a specified sequence of instructions to be executed, after
which execution resumes at the location where the call was made. However, they are much simpler
than function calls in that RoboSpeak subprograms can not receive any parameters, don't produce
return values, and are never invoked on objects. (RoboSpeak is not an object-oriented language.)</p><p>Two RoboSpeak instructions are directly related to subprogram calls:</p><ul><li><i>callsub N</i>: Calls a subprogram that starts at line N, causing program execution to jump to
            that line. Although this is similar to <i>goto N</i>, there is a crucial difference.
            While the <i>goto</i> command simply moves program execution from one place to another,
            <i>callsub</i> causes the robot to remember that it is making a subprogram call.
            More specifically, the robot will remember that there is a location at which
            the subprogram was called and where program execution is supposed to resume once the
            end of the subprogram's code has been reached.</li><li><i>return</i>: Marks the end of a subprogram's code. When this instruction is executed the robot
            returns to where the subprogram was called, and resumes program execution at the
            following RoboSpeak instruction.</li></ul><p>Here is an example of a tribe that makes use of subprogram calls. Notice that just like Scala
functions can call other functions, subprograms can also call other subprograms.</p><pre># A member of the Patrolman Tribe moves clockwise in rectangles,
# hacking every enemy it encounters. When it runs into obstacles,
# it takes a look around counterclockwise before proceeding.

start:
  callsub advance     # repeat three times: <span class="kw">try</span> to advance
  callsub advance
  callsub advance
  spin                # turn clockwise
  goto start

advance:              # move unless obstacle in front
  ifnempty cantmove
  move
  <span class="kw">return</span>
cantmove:             # spin around counterclockwise
  switch
  spin
  spin
  spin
  switch
  <span class="kw">return</span></pre></div></div>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="o1.robots.tribal.Tribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Tribe"></a>
      <a id="Tribe:Tribe"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Tribe$.html"><span class="name">Tribe</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#o1.robots.tribal.package@Tribe" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">This is the companion object of class <code>Tribe</code>.</p><div class="fullcomment"><div class="comment cmt"><p>This is the companion object of class <code>Tribe</code>.</p><p><b>NOTE TO STUDENTS: In this course, you don't need to understand how this object works or can be used.</b>
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p>the class <a href="Tribe.html" class="extype" name="o1.robots.tribal.Tribe">Tribe</a></p></span></dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer"> This document is part of the course materials for CSE-A1110 Ohjelmointi 1 at Aalto University. </div>


    </body>
      </html>
